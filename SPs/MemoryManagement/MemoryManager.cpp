/**
 * File:   MemoryManager.cpp
 * 
 * Authors: Wagner Fernando Gascho ( 12100779 ),
 *          Evandro  Coan (  )
 * 
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE ( THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION )
 *
 * Created on 30/04/2016
 */



#include "Debug.h"
#include "MemoryManager.h"
#include "Simulator.h"
#include "Traits.h"


using namespace std;


/**
 * @see Partition::Partition( unsigned int , unsigned int, bool ) member class declaration.
 */
Partition::Partition( unsigned int beginAddress, unsigned int endAddress, bool isFree ) 
{
    _beginAddress = beginAddress;
    _endAddress = endAddress;
    _isFree = isFree;
    
    DEBUGGERLN( 8, "Creating a partitition!" );
}

/**
 * @see Partition::getBeginAddress() member class declaration.
 */
unsigned int Partition::getBeginAddress() const 
{
    return _beginAddress;
}

/**
 * @see Partition::getEndAddress() member class declaration.
 */
unsigned int Partition::getEndAddress() const 
{
    return _endAddress;
}

/**
 * @see Partition::getLength() member class declaration.
 */
unsigned int Partition::getLength() const 
{
    return _endAddress - _beginAddress + 1;
}

/**
 * @see Partition::operator<( const Partition& ) member class declaration.
 */
bool Partition::operator<( const Partition& p ) const
{
    return this->_beginAddress < p._beginAddress;
}

/**
 * @see Partition::operator==( const Partition& ) member class declaration.
 */
bool Partition::operator==( const Partition& p ) const // note the implicit "this" pointer is const-qualified
{
    return this->_beginAddress == p._beginAddress;
}



/**
 * @see const unsigned int MemoryManager::maxAddress member class declaration.
 */
const unsigned int MemoryManager::maxAddress = Traits<MemoryManager>::physicalMemorySize - 1;

/**
 * @see MemoryManager::MemoryManager( MemoryAllocationAlgorithm ) member class declaration.
 */
MemoryManager::MemoryManager( MemoryAllocationAlgorithm algorithm )
{
    switch( algorithm )
    {
        case FirstFit:
        {
            currentStrategy = new _FirstFit();
            break;
        }
        case NextFit:
        {
            currentStrategy = new _NextFit();
            break;
        }
        case BestFit:
        {
            currentStrategy = new _BestFit();
            break;
        }
        case WorstFit:
        {
            currentStrategy = new _WorstFit();
            break;
        }
    }
    
    DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER" );
}

/**
 * @see MemoryManager::MemoryManager( const MemoryManager& ) member class declaration.
 */
MemoryManager::MemoryManager( const MemoryManager& source )
{
    this->currentStrategy = source.currentStrategy;
}

/**
 * @see MemoryManager::~MemoryManager() member class declaration.
 */
MemoryManager::~MemoryManager()
{
    delete currentStrategy;
    
    DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER \n\nDESTRUCTING\n\n\n" );
}

/**
 * @see MemoryManager::allocateMemory( unsigned int ) member class declaration.
 */
Partition* MemoryManager::allocateMemory( unsigned int size )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::allocateMemory( " + std::to_string( size ) + " )" );
    
    return currentStrategy->allocateMemory( size );
}

/**
 * @see MemoryManager::deallocateMemory( Partition* ) member class declaration.
 */
void MemoryManager::deallocateMemory( Partition* partition )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::deallocateMemory( " + std::to_string( reinterpret_cast<unsigned long> ( partition ) ) + " )" );
    
    this->currentStrategy->deletePartition( partition );
}

/**
 * @see MemoryManager::getNumPartitions() member class declaration.
 */
unsigned int MemoryManager::getNumPartitions()
{
    return this->currentStrategy->partitionListSize();
}

/**
 * @see MemoryManager::getPartition( unsigned int ) member class declaration.
 */
Partition* MemoryManager::getPartition( unsigned int index )
{
    if( index > this->getNumPartitions() )
    {
        return NULL;
    }
    
    return this->currentStrategy->getPartition( index );
}

/**
 * @see MemoryManager::showMemory() member class declaration.
 */
void MemoryManager::showMemory()
{
    FPRINT( 16, "\n" );
    DEBUGGERLN( 2 + 64, "\nI AM ENTERING IN MemoryManager::showMemory(0)" );
    
    if( this->currentStrategy->partitionListSize() == 0 )
    {
        FPRINTLN( 16, "0-%u:FREE %u", MemoryManager::maxAddress, MemoryManager::maxAddress + 1 );
        return;
    }
    
    int64_t      holeSize;
    unsigned int nextStartAddress;
    
    unsigned int partitionListSize      = this->currentStrategy->partitionListSize() - 1;
    auto         currentElementIterator = this->currentStrategy->getPartitionsListIterator();
    
    unsigned int currentStartAddress = ( *currentElementIterator ).getBeginAddress();
    unsigned int currentEndAddress   = ( *currentElementIterator ).getEndAddress();
    
    if( currentStartAddress > 0 )
    {
        FPRINTLN( 16, "0-%u:FREE %u", currentStartAddress - 1, currentStartAddress );
    }
    
    for( unsigned int partitionIndex = 0; partitionIndex < partitionListSize; partitionIndex++ )
    {
        FPRINTLN( 16, "%u-%u:ALLOCATED %u", currentStartAddress, currentEndAddress, ( *currentElementIterator ).getLength() );
        ++currentElementIterator;
        
        nextStartAddress = ( *currentElementIterator ).getBeginAddress();
        holeSize         = nextStartAddress - currentEndAddress - 1;
        
        if( holeSize > 0 )
        {
            FPRINTLN( 16, "%u-%u:FREE %i", currentEndAddress + 1, nextStartAddress - 1, holeSize );
        }
        
        currentStartAddress = ( *currentElementIterator ).getBeginAddress();
        currentEndAddress   = ( *currentElementIterator ).getEndAddress();
    }
    
    FPRINTLN( 16, "%u-%u:ALLOCATED %u", currentStartAddress, currentEndAddress, ( *currentElementIterator ).getLength() );
    holeSize = MemoryManager::maxAddress - ( *currentElementIterator ).getEndAddress();
    
    DEBUGGERLN( 64, "( showMemory ) holeSize: %lld, \n( *currentElementIterator ).getEndAddress():%u, \nMemoryManager::maxAddress: %u,",
                                    holeSize,         ( *currentElementIterator ).getEndAddress(),      MemoryManager::maxAddress );
    
    if( holeSize > 0 )
    {
        FPRINTLN( 16, "%u-%lld:FREE %lld", ( *currentElementIterator ).getEndAddress() + 1, MemoryManager::maxAddress, holeSize );
    }
}


