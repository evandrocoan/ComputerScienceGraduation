/**
 * File:   MemoryManager.cpp
 * 
 * Authors: Wagner Fernando Gascho ( 12100779 ),
 *          Evandro  Coan (  )
 * 
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE ( THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION )
 *
 * Created on 30/04/2016
 */



#include "Debug.h"
#include "MemoryManager.h"
#include "Simulator.h"
#include "Traits.h"


using namespace std;


/**
 * @see Partition::Partition( unsigned int , unsigned int, bool ) member class declaration.
 */
Partition::Partition( unsigned int beginAddress, unsigned int endAddress, bool isFree ) 
{
    _beginAddress = beginAddress;
    _endAddress = endAddress;
    _isFree = isFree;
    
    DEBUGGERLN( 8, "Creating a partitition!" );
}

/**
 * @see Partition::getBeginAddress() member class declaration.
 */
unsigned int Partition::getBeginAddress() const 
{
    return _beginAddress;
}

/**
 * @see Partition::getEndAddress() member class declaration.
 */
unsigned int Partition::getEndAddress() const 
{
    return _endAddress;
}

/**
 * @see Partition::getLength() member class declaration.
 */
unsigned int Partition::getLength() const 
{
    return _endAddress - _beginAddress + 1;
}

/**
 * @see Partition::operator<( const Partition& ) member class declaration.
 */
bool Partition::operator<( const Partition& p ) const
{
    return this->_beginAddress < p._beginAddress;
}

/**
 * @see Partition::operator==( const Partition& ) member class declaration.
 */
bool Partition::operator==( const Partition& p ) const // note the implicit "this" pointer is const-qualified
{
    return this->_beginAddress == p._beginAddress;
}



/**
 * @see MemoryManager::MemoryManager( MemoryAllocationAlgorithm ) member class declaration.
 */
MemoryManager::MemoryManager( MemoryAllocationAlgorithm algorithm )
{
    switch( algorithm )
    {
        case FirstFit:
        {
            currentStrategy = new _FirstFit();
            break;
        }
        case NextFit:
        {
            currentStrategy = new _NextFit();
            break;
        }
        case BestFit:
        {
            currentStrategy = new _BestFit();
            break;
        }
        case WorstFit:
        {
            currentStrategy = new _WorstFit();
            break;
        }
    }
    
    DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER" );
}

/**
 * @see MemoryManager::MemoryManager( const MemoryManager& ) member class declaration.
 */
MemoryManager::MemoryManager( const MemoryManager& orig )
{
    this->currentStrategy = orig.currentStrategy;
}

/**
 * @see MemoryManager::~MemoryManager() member class declaration.
 */
MemoryManager::~MemoryManager()
{
    delete currentStrategy;
    
    DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER \n\nDESTRUCTING\n\n\n" );
}

/**
 * @see MemoryManager::allocateMemory( unsigned int ) member class declaration.
 */
Partition* MemoryManager::allocateMemory( unsigned int size )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::allocateMemory( " + std::to_string( size ) + " )" );
    
    return currentStrategy->allocateMemory( size );
}

/**
 * @see MemoryManager::deallocateMemory( Partition* ) member class declaration.
 */
void MemoryManager::deallocateMemory( Partition* partition )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::deallocateMemory( " + std::to_string( reinterpret_cast<unsigned long> ( partition ) ) + " )" );
    
    this->currentStrategy->deletePartition( partition );
}

/**
 * @see MemoryManager::getNumPartitions() member class declaration.
 */
unsigned int MemoryManager::getNumPartitions()
{
    return this->currentStrategy->partitionListSize();
}

/**
 * @see MemoryManager::getPartition( unsigned int ) member class declaration.
 */
Partition* MemoryManager::getPartition( unsigned int index )
{
    if( index > this->getNumPartitions() )
    {
        return NULL;
    }
    
    return this->currentStrategy->getPartition( index );
}

/**
 * @see MemoryManager::showMemory() member class declaration.
 */
void MemoryManager::showMemory()
{
    if( this->currentStrategy->partitionListSize() == 0 )
    {
        FPRINTLN( 16, "0-%d:FREE %d", ( maxAddress - 1 ), maxAddress );
        return;
    }
    
    int end;
    int holeSize;
    
    int  beg                    = 0;
    auto currentElementIterator = this->currentStrategy->getPartitionsListIterator();
    int  start                  = ( *currentElementIterator ).getBeginAddress();
    
    if( start > 1 )
    {
        FPRINTLN( 16, "0-%d:FREE %d", start-1, start );
    }
    
    for( int i = 0; i < this->currentStrategy->partitionListSize() - 1; i++ )
    {
        end = ( *currentElementIterator ).getEndAddress();
        FPRINTLN( 16, "%d-%d:ALLOCATED %d", ( *currentElementIterator ).getBeginAddress(), end, ( *currentElementIterator ).getLength() );
        
        currentElementIterator++;
        
        beg      = ( *currentElementIterator ).getBeginAddress();
        holeSize = ( beg - end ) + 1;
        
        if( holeSize <= 1 )
        {
            FPRINTLN( 16, "%d-%d:FREE %d", end + 1, beg, holeSize );
        }
    }
    
    end = ( *currentElementIterator ).getBeginAddress();
    FPRINTLN( 16, "%d-%d:ALLOCATED %d", ( *currentElementIterator ).getBeginAddress(), end, ( *currentElementIterator ).getLength() );
    
    beg      = maxAddress;
    holeSize = ( beg - end )+1;
        
    if( holeSize <= 1 )
    {
        FPRINTLN( 16, "%d-%d:FREE %d", end + 1, beg, holeSize );
    }
}


