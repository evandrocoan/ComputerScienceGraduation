/**
 * File:   MemoryManager.cpp
 * 
 * Authors: Wagner Fernando Gascho ( 12100779 ),
 *          Evandro  Coan (  )
 * 
 * Strategy: INSERT THE MEMORY MANAGEMENT SCHEMA HERE ( THE ALGORITHM YOU ARE IMPLEMENTING -- RANDOMLY GENERATED BY MOODLE AS A VARIATION )
 *
 * Created on 30/04/2016
 */



#include <iostream>
#include <algorithm>

#include "Debug.h"
#include "MemoryManager.h"
#include "Simulator.h"
#include "Traits.h"


using namespace std;


/**
 * @see Partition::Partition( unsigned int , unsigned int, bool ) member class declaration.
 */
Partition::Partition( unsigned int beginAddress, unsigned int endAddress, bool isFree ) 
{
    _beginAddress = beginAddress;
    _endAddress = endAddress;
    _isFree = isFree;
    
    DEBUGGERLN( 8, "Creating a partitition!" );
}

/**
 * @see Partition::getBeginAddress() member class declaration.
 */
unsigned int Partition::getBeginAddress() const 
{
    return _beginAddress;
}

/**
 * @see Partition::getEndAddress() member class declaration.
 */
unsigned int Partition::getEndAddress() const 
{
    return _endAddress;
}

/**
 * @see Partition::getLength() member class declaration.
 */
unsigned int Partition::getLength() const 
{
    return _endAddress - _beginAddress + 1;
}

/**
 * @see Partition::operator<( const Partition& ) member class declaration.
 */
bool Partition::operator<( const Partition& p ) const
{
    return this->_beginAddress < p._beginAddress;
}

/**
 * @see Partition::operator==( const Partition& ) member class declaration.
 */
bool Partition::operator==( const Partition& p ) const
{
    return this->_beginAddress == p._beginAddress;
}



/**
 * @see MemoryManager::MemoryManager( MemoryAllocationAlgorithm ) member class declaration.
 */
MemoryManager::MemoryManager( MemoryAllocationAlgorithm algorithm ) : 
maxAddress( Traits<MemoryManager>::physicalMemorySize )
{
    this->algorithm  = algorithm;
    
    switch( algorithm )
    {
       case FirstFit:{functions= new _FirstFit( this );   break;}
       case NextFit:{functions= new _NextFit( this );   break;}
       case BestFit:{functions= new _BestFit( this );   break;}
       case WorstFit:{functions= new _WorstFit( this );   break;}
    }
    
    DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER" );
}

/**
 * @see MemoryManager::MemoryManager( const MemoryManager& ) member class declaration.
 */
MemoryManager::MemoryManager( const MemoryManager& orig )
{
}

/**
 * @see MemoryManager::~MemoryManager() member class declaration.
 */
MemoryManager::~MemoryManager()
{
      delete( functions );
      
      DEBUGGERLN( 4, "\n\n\n\n\n\n\nI AM IN HERE %s \n\n\n\n\n\n\n", "In HERER \n\nDESTRUCTING\n\n\n" );
}

/**
 * @see MemoryManager::allocateMemory( unsigned int ) member class declaration.
 */
Partition* MemoryManager::allocateMemory( unsigned int size )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::allocateMemory( " + std::to_string( size ) + " )" );
    
    return functions->allocateMemory( size );
}

/**
 * @see MemoryManager::deallocateMemory( Partition* ) member class declaration.
 */
void MemoryManager::deallocateMemory( Partition* partition )
{
    Debug::cout( Debug::Level::trace, "MemoryManager::deallocateMemory( " + std::to_string( reinterpret_cast<unsigned long> ( partition ) ) + " )" );
    
    auto foundElementIterator = std::find( this->partitions.begin(), this->partitions.end(), *partition );
    partitions.erase( foundElementIterator );
}

/**
 * @see MemoryManager::getNumPartitions() member class declaration.
 */
unsigned int MemoryManager::getNumPartitions()
{
    return partitions.size();
}

/**
 * @see MemoryManager::getPartition( unsigned int ) member class declaration.
 */
Partition* MemoryManager::getPartition( unsigned int index )
{
    Partition* returnPartition;
    
    if( index > this->partitions.size() )
    {
        return NULL;
    }
    
    return &( *( std::next( this->partitions.begin(), index ) ) );
}

/**
 * @see MemoryManager::showMemory() member class declaration.
 */
void MemoryManager::showMemory()
{
    // INSERT YOUR CODE TO SHOW THE MEMORY MAP, IN THE FOLLOWING FORMAT
    // <beginAddress>-<endAddress>: <FREE|ALLOCATED> <size>
    // Exemplo:
    /*
      0-1499:FREE 1500
      1500-1999:ALLOCATED 500
      2000-2999:ALLOCATED 1000
      3000-9999:FREE 7000
      10000-19999:ALLOCATED 10000
      20000-1000000:FREE 800000
    */
    
    
    if( partitions.size() == 0 )
    {
        // cout<<"0-"<<( maxAddress-1 )<<":FREE "<<maxAddress<<endl;
        FPRINTLN( 16, "0-%d:FREE %d", ( maxAddress - 1 ), maxAddress );
        
        return;
    }
    
    auto index = partitions.begin();
    
    int start= ( *index ).getBeginAddress();
    
    if( start > 1 )
    {
        // cout<<"0-"<<start-1<<":FREE "<<start<<endl;
        FPRINTLN( 16, "0-%d:FREE %d", start-1, start );
    }
    
    int holeSize, end, beg =0;
    
    for( int i = 0; i< partitions.size() - 1; i++ )
    {
        end = ( *index ).getEndAddress();
        
        // cout<< ( *index )->getBeginAddress() <<"-"<<end<<":ALLOCATED "<<( *index )->getLength()<<endl;
        FPRINTLN( 16, "%d-%d:ALLOCATED %d", ( *index ).getBeginAddress(), end, ( *index ).getLength() );
        
        index++;
        
        beg      = ( *index ).getBeginAddress();
        holeSize = ( beg- end ) + 1;
        
        if( holeSize <= 1 )
        {
            FPRINTLN( 16, "%d-%d:FREE %d", end + 1, beg, holeSize );
        }
    }
    
    end = ( *index ).getBeginAddress();
    
    // cout<< ( *index )->getBeginAddress() <<"-"<<end<<":ALLOCATED "<<( *index )->getLength()<<endl;
    FPRINTLN( 16, "%d-%d:ALLOCATED %d", ( *index ).getBeginAddress(), end, ( *index ).getLength() );
    
    beg      = maxAddress;
    holeSize = ( beg - end )+1;
        
    if( holeSize <= 1 )
    {
        // cout<< ( end+1 ) <<"-"<<( beg )<<":FREE "<<holeSize<<endl;
        FPRINTLN( 16, "%d-%d:FREE %d", end + 1, beg, holeSize );
    }
}


